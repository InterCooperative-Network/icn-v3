use axum::Server;
use cid::Cid;
use icn_identity::Did;
use icn_mesh_jobs::{create_app, AppState};
use icn_types::jobs::{Bid, JobRequest, NodeMetadata, ResourceEstimate, ResourceRequirements};
use reqwest::Client;
use serde_json::{json, Value};
use sqlx::{migrate::Migrator, SqlitePool};
use std::{net::SocketAddr, sync::Arc, str::FromStr};
use tempfile::NamedTempFile;
use tokio::task::JoinHandle;

static MIGRATOR: Migrator = sqlx::migrate!("crates/services/icn-mesh-jobs/migrations");

/// Starts your Axum service with an in-memory SQLite DB and returns the base URL.
async fn spawn_app() -> String {
    // 1. Create a temp file for SQLite
    let tmp = NamedTempFile::new().expect("failed to create temp file");
    let db_url = format!("sqlite://{}?mode=rwc", tmp.path().display());

    // 2. Connect & run migrations
    let pool = SqlitePool::connect(&db_url)
        .await
        .expect("failed to connect to SQLite");
    
    // It's good practice to check if the migrations directory exists or handle error here
    // For now, we proceed assuming MIGRATOR.run will provide a clear error if path is wrong.
    MIGRATOR.run(&pool).await.expect("migrations failed. Check path in sqlx::migrate! and ensure migrations directory exists.");

    // 3. Build your AppState & Axum app
    let state = AppState::new(pool.clone());
    let app = create_app(Arc::new(state));

    // 4. Bind to a random port and spawn server
    let listener = tokio::net::TcpListener::bind("127.0.0.1:0")
        .await
        .expect("failed to bind random port");
    let addr = listener.local_addr().unwrap();
    let server = Server::from_tcp(listener)
        .unwrap()
        .serve(app.into_make_service());
    tokio::spawn(server);

    format!("http://{}", addr)
}

#[tokio::test]
async fn governed_executor_selection_flow() {
    let base_url = spawn_app().await;
    let client = Client::new();

    // --- 1. Create a JobRequest with governed-selector metadata ---
    let wasm_cid_str = "ba<x_bin_411>jashacgmzuxecyqaqpbkcatgrifx4ypcwz2gwgk4jzn5kbr7yvkeyqlfy"; // Example CID V1
    let wasm_cid = Cid::try_from(wasm_cid_str).unwrap();
    
    let create_job_payload = json!({
        "wasm_cid": wasm_cid.to_string(),
        "description": "Test governed selection job",
        "requirements": {
            "cpu": 1, // u32
            "memory_mb": 128, // u32
            "storage_mb": 0, // u32 - Added
            "bandwidth": 0 // u32 - Added
        },
        "metadata": {
            "selector": "governed",
            "region_filter": "us-west",
            "min_reputation": "75.0" // String, parsed by server
        }
        // deadline: None - Optional, so fine to omit
    });
    let resp = client
        .post(&format!("{}/jobs", base_url))
        .json(&create_job_payload)
        .send()
        .await
        .expect("Job creation request failed");
    assert!(resp.status().is_success(), "Job creation failed with status: {}, body: {}", resp.status(), resp.text().await.unwrap_or_default());

    let body: Value = resp.json().await.unwrap();
    let job_id_str = body.get("job_id").and_then(Value::as_str).expect("job_id not found in response or not a string");
    let job_id = Cid::try_from(job_id_str).expect("invalid CID returned for job_id");

    // --- 2. Submit a set of bids with varying metadata ---
    let bids_data = vec![
        // (bidder_did_str, region, reputation, price)
        ("did:icn:testnode-east-1", "us-east", 100.0, 10u64),
        ("did:icn:testnode-west-lowrep", "us-west", 50.0, 5u64),
        ("did:icn:testnode-west-highrep", "us-west", 80.0, 8u64),
    ];

    for (bidder_did_str, region, reputation, price) in bids_data {
        let bidder_did = Did::from_str(bidder_did_str).expect("Failed to parse DID string");
        let bid_payload = json!({
            "job_id": job_id.to_string(),
            "bidder": bidder_did.to_string(),
            "estimate": { // Corresponds to ResourceEstimate
                "cpu": 1, // u32
                "memory_mb": 128, // u32
                "storage_mb": 0, // u32 - Added
                "bandwidth": 0, // u32 - Added
                "estimated_duration_secs": null // Option<u64> - Added as null
            },
            "price": price, // TokenAmount (u64)
            "node_metadata": { // Corresponds to NodeMetadata
                "region": region, // Option<String>
                "reputation": reputation // Option<f64>
            }
            // id: None - Optional, auto-generated by DB
            // reputation_score: None - Optional, fetched by server or could be part of node_metadata
        });
        let res = client
            .post(&format!("{}/jobs/{}/bids", base_url, job_id_str))
            .json(&bid_payload)
            .send()
            .await
            .expect("Bid submission failed");
        assert!(res.status().is_success(), "Bid submission failed for {}: Status {}, body: {}", bidder_did_str, res.status(), res.text().await.unwrap_or_default());
    }

    // --- 3. Trigger the assignment endpoint ---
    let res = client
        .post(&format!("{}/jobs/{}/assign", base_url, job_id_str))
        .send()
        .await
        .expect("Assignment request failed");
    assert!(res.status().is_success(), "Assignment failed: Status {}, body: {}", res.status(), res.text().await.unwrap_or_default());

    let assign_resp: Value = res.json().await.unwrap();
    let assigned_did_str = assign_resp
        .get("assigned_bidder_did")
        .and_then(Value::as_str)
        .expect("assigned_bidder_did not found in assignment response");
    assert_eq!(assigned_did_str, "did:icn:testnode-west-highrep", "Incorrect bidder assigned");

    // --- 4. Fetch the job to verify its stored status --- 
    // This step might be redundant if assign_resp is trusted, but good for full verification.
    let res = client
        .get(&format!("{}/jobs/{}", base_url, job_id_str))
        .send()
        .await
        .expect("Fetch job after assignment failed");
    assert!(res.status().is_success(), "Fetching job after assignment failed: Status {}, body: {}", res.status(), res.text().await.unwrap_or_default());

    let job_details_resp: Value = res.json().await.unwrap();
    let status_val = job_details_resp.get("status").expect("status field not found in job details");
    
    // Assuming JobStatus::Assigned { bidder } serializes to something like { "Assigned": { "bidder": "did_string" } }
    // or { "status_type": "Assigned", "bidder": "did_string" } depending on icn_types::jobs::JobStatus serde representation.
    // The test initially had: status.get("assigned_to").and_then(Value::as_str)
    // Let's check for a structure that's common with Axum for enums with fields.
    // If JobStatus is an externally tagged enum (default for serde):
    // e.g., { "Assigned": { "bidder": "did:icn:testnode-west-highrep" } }
    if let Some(assigned_bidder_val) = status_val.get("Assigned").and_then(|v| v.get("bidder")) {
        assert_eq!(assigned_bidder_val.as_str().unwrap(), "did:icn:testnode-west-highrep", "Job status does not reflect correct assignment");
    } else {
        // Fallback or alternative check if JobStatus has a different serde representation
        // For example, if it's internally tagged or flattened.
        // This part might need adjustment based on actual JobStatus serialization.
        panic!("JobStatus::Assigned structure not as expected in JSON: {:?}", status_val);
    }
} 