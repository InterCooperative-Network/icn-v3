# CCL Specification (Draft) - Chapter 7: Examples and Walkthroughs

This chapter provides practical examples of CCL code, demonstrating how various constructs are used to define cooperative logic. Each example will be accompanied by:

*   A conceptual mapping to the `icn-ccl-dsl` Abstract Syntax Tree (AST), highlighting how CCL structures are represented internally.
*   An expected sequence of custom `Opcode`s generated by `icn-ccl-wasm-codegen`, illustrating the transformation into a lower-level instruction set.
*   A list of key `host-abi` functions that the resulting WASM module would interact with during runtime execution.

## 7.1 Multi-Stage Proposal Lifecycle: "Budget Increase"

This example implements a three-stage workflow for budget proposals: Draft, Voting, and Approved/Rejected. It demonstrates metadata definition, state transitions based on events and conditions, and interaction with core ICN primitives like data anchoring, resource metering, and token minting.

### 7.1.1 CCL Source: `budget_increase_proposal.ccl`

```ccl
// budget_increase_proposal.ccl (Revised based on RFCs 0003-0007)

proposal_def "Budget Increase" {
  description "Request to raise the operational budget for the next fiscal period."
  // Default duration for proposal-level concerns (e.g., overall lifecycle if not stage-specific)
  // For now, this is a String. Canonical Duration type is pending (RFC-0007 Future Extensions).
  default_duration    "14d" 
  min_votes   5     // Number (Canonical Type: Number - i64 or u64)

  // Context variables available at runtime for an instance of this proposal,
  // typically populated by the host into contract.properties:
  // - contract.properties.id: String (Unique ID of this proposal instance)
  // - contract.properties.submitter_id: DID (String, DID Format)
  // - contract.properties.content: Any (The full content/details of the budget request)
  // - contract.properties.valid_amount: Boolean (Pre-validated flag)
  // - contract.properties.definition.description: String (from proposal_def)
  // - contract.properties.definition.default_duration: String (from proposal_def)
  // - contract.properties.definition.min_votes: Number (from proposal_def)
}

process_def "BudgetIncreaseProcess" {
  // Defines the state machine for this proposal type
  stages {
    stage "Draft" {
      enter_action { 
        // HOST_ACTION: maps to host_log_event(name: String, detail: String, context: Object)
        log_event( 
            name: "budget_proposal.draft_started", 
            detail: "New budget proposal instance created and entered Draft stage.",
            // Accessing proposal instance ID from context
            context: { proposal_id: contract.properties.id } 
        );
      }
      on "submit" { // Event "submit"
        // Condition uses a pre-validated boolean flag from the proposal's instance properties
        if contract.properties.valid_amount == true { 
          // HOST_ACTION: maps to host_transition_stage(stage_name: String)
          transition_to "Voting" 
        } else {
          // HOST_ACTION: maps to host_log_event(...)
          log_event(
            name: "budget_proposal.invalid_submission",
            level: "warn", 
            detail: "Submission rejected due to invalid amount.",
            context: { proposal_id: contract.properties.id, reason: "InvalidAmount" }
          );
          // Stays in "Draft"
        }
      }
    } // End of "Draft" stage

    stage "Voting" {
      // Stage-specific properties, conceptually available via contract.current_stage.definition.*
      // For now, this is a String. Canonical Duration type is pending (RFC-0007 Future Extensions).
      duration "10d" 

      enter_action {
        // HOST_ACTION: maps to host_anchor_data(path: String, data: Any, metadata: Object) -> String? (CID)
        anchor_data { 
            // Path constructed using stdlib concat() and proposal instance ID
            path concat("proposals/", contract.properties.id, "/budget_request_v1.ccl_content"), 
            data contract.properties.content, // Anchors the proposal content
            metadata { contentType: "application/vnd.icn.ccl.proposal.v1+json" } 
        }
        // HOST_ACTION: maps to host_log_event(...)
        log_event(
            name: "budget_proposal.voting_started",
            detail: "Proposal content anchored. Voting period now open.",
            // Accessing stage-specific duration; assuming runtime makes this available
            // e.g., contract.current_stage.definition.duration or similar path
            context: { proposal_id: contract.properties.id, voting_duration: self.duration } 
        );
      }
      
      on "vote_cast" { // Event "vote_cast"
        // HOST_ACTION: maps to host_perform_metered_action(action_name: String, resource_type: ResourceTypeName, amount: Number)
        // ResourceTypeName is a String enum as per RFC-0007
        perform_metered_action("ProcessIncomingVote", "CPU", 10); 
      }

      on "voting_closed" { // Event "voting_closed"
        // Assumed context variables available from voting system via trigger.parameters
        // (Types: Number as per RFC-0007)
        // - trigger.parameters.approved_count: Number
        // - trigger.parameters.rejected_count: Number
        // - trigger.parameters.total_votes_cast: Number
        
        // Accessing min_votes from the proposal definition's properties
        if trigger.parameters.approved_count >= contract.properties.definition.min_votes { 
          // HOST_ACTION: maps to host_transition_stage(stage_name: String)
          transition_to "Approved"
        } else {
          // HOST_ACTION: maps to host_transition_stage(stage_name: String)
          transition_to "Rejected"
        }
      }
    } // End of "Voting" stage

    stage "Approved" {
      enter_action {
        // HOST_ACTION: maps to host_log_event(...)
        log_event(
            name: "budget_proposal.approved",
            detail: "Budget proposal approved.",
            context: { proposal_id: contract.properties.id }
        );
        // HOST_ACTION: maps to host_mint_token(token_type: String, recipient: DID, amount: Number, data: Object) -> String? (TokenID/ReceiptID)
        mint_token {
          token_type      "BudgetApprovalReceipt" // String
          recipient contract.properties.submitter_id // DID (String)
          amount    1 // Number
          data      { 
            proposal_id: contract.properties.id, // String
            // timestamp() is a stdlib function returning Number (u64) as per RFC-0006
            approved_on: timestamp(), 
            // ⚠️ TODO (RFC-0008): Mechanism for accessing results of previous host actions (like anchor_data CID) is needed.
            // Current `self.previous_stage_anchor_cid` is conceptual and not yet supported by defined context/ABI.
            // Placeholder: document_cid: get_context_value("contract.state.last_anchor_cid") 
            document_cid: self.previous_stage_anchor_cid 
          } 
        }
      }
    } // End of "Approved" stage

    stage "Rejected" {
        enter_action {
            // HOST_ACTION: maps to host_log_event(...)
            log_event(
                name: "budget_proposal.rejected",
                level: "info", // String
                detail: "Budget proposal rejected.",
                context: { proposal_id: contract.properties.id }
            );
        }
    } // End of "Rejected" stage

  } // End of stages
} // End of process_def
```

### 7.1.2 Purpose & Overview

This CCL contract defines a structured, multi-stage process for handling "Budget Increase" proposals. It ensures that proposals are logged, their content is verifiably anchored, voting is metered, and a non-fungible token receipt is issued upon successful approval. The process transitions through "Draft," "Voting," and "Approved" (or "Rejected") stages based on defined events and conditions.

### 7.1.3 Key Constructs & Semantics

*   **`proposal_def`**: Declares metadata and default parameters for the "Budget Increase" proposal type, such as its `description`, default `duration` for actions/stages, and `min_votes` required for approval.
*   **`process_def`**: Defines the state machine (`stages`) for the proposal lifecycle.
*   **`stage "<Name>"`**: Represents a distinct state in the process. Each stage can have:
    *   `enter_action {}`: A block of actions executed immediately upon transitioning into that stage.
    *   `on "<event_name>" {}`: Defines event handlers that are evaluated when the specified event occurs while the process is in this stage.
    *   Properties like `duration` specific to that stage.
*   **`if <condition> { ... } else { ... }`**: Standard conditional logic. Conditions can reference proposal properties (e.g., `proposal.valid_amount`) or tallies from other processes (e.g., `tally.approved_count`).
*   **`transition_to "<StageName>"`**: An action (likely a host call) that moves the process instance to a different stage.
*   **`log_event(...)`**: A function call to log structured events, mapping to `host_log_message`.
*   **`anchor_data {}`**: An action to store data verifiably on the ICN DAG, mapping to relevant host ABI calls for data writing and anchoring.
*   **`perform_metered_action(...)`**: Explicitly declares that an action consumes resources, interfacing with the ICN economics system via `host_check_resource_authorization` and `host_record_resource_usage`.
*   **`mint_token {}`**: An action to create new tokens, mapping to `host_mint_token`.
*   **Contextual Variables**: The CCL code relies on runtime-provided context (e.g., `proposal.id`, `proposal.submitter_id`, `tally.approved_count`). `self.` refers to properties defined in the current CCL block's scope (e.g., a stage's own `duration`). `timestamp()` is an example of a CCL standard library function.

### 7.1.4 Conceptual DSL AST Mapping (`icn-ccl-dsl`) (Excerpt)

The `icn-ccl-compiler` would lower the CCL source into `Vec<DslModule>` instances.

*   **`proposal_def "Budget Increase" { ... }` block:**
    ```rust
    DslModule::Proposal {
        name: "Budget Increase".to_string(),
        version: None, // No version specified in this example's proposal_def
        rules: vec![
            Rule { key: "description".to_string(), value: RuleValue::String("Request to raise...".to_string()) },
            Rule { key: "duration".to_string(), value: RuleValue::String("14d".to_string()) }, // Or a Duration type
            Rule { key: "min_votes".to_string(), value: RuleValue::Number(5.0.into()) },
        ],
    }
    ```

*   **`process_def "BudgetIncreaseProcess" { ... }` block:**
    ```rust
    DslModule::Section { // process_def often maps to a generic Section or a specific Process DslModule
        kind: "process_def".to_string(),
        title: Some("BudgetIncreaseProcess".to_string()),
        rules: vec![ /* rules representing stages */ ],
    }
    ```
    Each `stage` within `stages { ... }` would become a nested `DslModule::Section` with `kind: "stage"`.

*   **`stage "Draft" { enter_action { log_event(...) } ... }`:**
    A `DslModule::Section` for the stage:
    ```rust
    DslModule::Section {
        kind: "stage".to_string(),
        title: Some("Draft".to_string()),
        rules: vec![
            Rule { // Representing enter_action
                key: "enter_action".to_string(),
                value: RuleValue::Map(vec![ // Map of actions
                    Rule { 
                        key: "log_event".to_string(), // Function call representation
                        value: RuleValue::Map(vec![
                            Rule { key: "name".to_string(), value: RuleValue::String("budget_proposal.draft_started".to_string()) },
                            Rule { key: "detail".to_string(), value: RuleValue::String("New budget proposal...".to_string()) },
                            Rule { key: "context".to_string(), value: RuleValue::Map(vec![
                                Rule { key: "proposal_id".to_string(), value: RuleValue::Expression("proposal.id".to_string()) }
                            ])},
                        ]),
                    },
                ]),
            },
            Rule { // Representing on "submit" handler
                key: "on".to_string(),
                value: RuleValue::Map(vec![
                    Rule { key: "event_name".to_string(), value: RuleValue::String("submit".to_string()) },
                    Rule { key: "handler_logic".to_string(), value: RuleValue::If(
                        IfExpr {
                            condition_raw: "proposal.valid_amount == true".to_string(),
                            then_rules: vec![ /* Rule for transition_to "Voting" */ ],
                            else_rules: Some(vec![ /* Rule for log_event and implicit stay */ ]),
                        }
                    )},
                ]),
            },
            // ... other rules or properties of the stage ...
        ],
    }
    ```

*   **`anchor_data { path ..., data ..., metadata ... }` within an `enter_action`:**
    This would be an `ActionStep` variant within the DSL, perhaps:
    ```rust
    // Conceptual ActionStep variant within a DslModule::ActionHandler or similar structure
    ActionStep::Anchor {
        path_expr: Some("concat("proposals/", proposal.id, "/budget_request_v1.ccl_content")".to_string()),
        data_ref: Some("proposal.content".to_string()), // Reference to context data
        metadata: Some(vec![
            Rule { key: "contentType".to_string(), value: RuleValue::String("application/vnd.icn.ccl.proposal.v1+json".to_string()) }
        ]),
        content_ref: None, // as data_ref is used
    }
    ```

*   **`perform_metered_action("ProcessIncomingVote", ResourceType.CPU, 10);`**
    ```rust
    ActionStep::PerformMeteredAction {
        action_name: "ProcessIncomingVote".to_string(),
        resource_type: "CPU".to_string(), // Assuming ResourceType enum variant mapped to string
        amount: 10,
    }
    ```

### 7.1.5 Conceptual Opcode Sequence (`icn-ccl-wasm-codegen`)

The `WasmGenerator` would convert the DSL AST into a linear sequence of custom `Opcode`s. This is a simplified conceptual flow:

```rust
// Program.ops:
[
    // Proposal Definition part
    Opcode::DefineContextSchema { schema_name: "Budget Increase" }, // Or similar to set up expected context
    Opcode::SetProperty { key: "proposal_def.description", value_json: ""Request to raise..."" },
    Opcode::SetProperty { key: "proposal_def.duration", value_json: ""14d"" },
    Opcode::SetProperty { key: "proposal_def.min_votes", value_json: "5" },

    // Process Definition: BudgetIncreaseProcess
    Opcode::BeginProcessDef { name: "BudgetIncreaseProcess" },

    // Stage: Draft
    Opcode::DefineStage { name: "Draft" },
    Opcode::OnStageEnter { stage_name: "Draft" }, // Marks block for stage entry actions
        Opcode::CallHostFunction { // For log_event
            function_name: "log_event".to_string(),
            // Arguments serialized, e.g., as JSON array of objects or a single JSON object
            args_json: "{\"name\":\"budget_proposal.draft_started\", \"detail\":\"...\", \"context\":{\"proposal_id\":\"<resolved_proposal.id>\"}}"
        },
    Opcode::EndStageActions, // End of enter_action
    
    Opcode::OnEvent { event_name: "submit", stage_context: "Draft" }, // Handler for "submit" in "Draft"
        Opcode::IfConditionExpr { condition_expr_string: "proposal.valid_amount == true" }, // Host evaluates this
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Voting"" },
        Opcode::Else,
            Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_proposal.invalid_submission\", ...}" },
        Opcode::EndIf,
    Opcode::EndOnEvent, // End of "submit" handler

    // Stage: Voting
    Opcode::DefineStage { name: "Voting" },
    Opcode::SetStageProperty { stage_name: "Voting", key: "duration", value_json: ""10d"" },
    Opcode::OnStageEnter { stage_name: "Voting" },
        Opcode::AnchorData { // Resolves expressions and context data before calling host_anchor
            path_expr: "concat("proposals/", proposal.id, "/budget_request_v1.ccl_content")",
            data_ref: "proposal.content",
            metadata_json: "{\"contentType\":\"application/vnd.icn.ccl.proposal.v1+json\"}"
        },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_proposal.voting_started\", ...}" },
    Opcode::EndStageActions,

    Opcode::OnEvent { event_name: "vote_cast", stage_context: "Voting" },
        Opcode::UseResource { resource_type: "CPU", amount: 10 }, // "ProcessIncomingVote" is descriptive label
        // Potentially other opcodes for vote processing if not fully on host
    Opcode::EndOnEvent,

    Opcode::OnEvent { event_name: "voting_closed", stage_context: "Voting" },
        Opcode::IfConditionExpr { condition_expr_string: "tally.approved_count >= proposal.min_votes" },
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Approved"" },
        Opcode::Else,
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Rejected"" },
        Opcode::EndIf,
    Opcode::EndOnEvent,

    // Stage: Approved
    Opcode::DefineStage { name: "Approved" },
    Opcode::OnStageEnter { stage_name: "Approved" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_proposal.approved\", ...}" },
        Opcode::MintToken {
            token_type: "BudgetApprovalReceipt",
            recipient_ref: "proposal.submitter_id",
            amount: 1,
            data_json_expr: "{\"proposal_id\": proposal.id, \"approved_on\": timestamp(), \"document_cid\": self.previous_stage_anchor_cid }"
        },
    Opcode::EndStageActions,
    
    // Stage: Rejected
    Opcode::DefineStage { name: "Rejected" },
    Opcode::OnStageEnter { stage_name: "Rejected" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_proposal.rejected\", ...}" },
    Opcode::EndStageActions,

    Opcode::EndProcessDef,
]
```

### 7.1.6 Runtime (Host-ABI) Calls Invoked

The generated WASM, when executed by `icn-runtime`, would interact with `icn_host` functions:

| CCL Action / Construct             | Conceptual Host ABI Interaction(s)                                                                                                                               | Key Parameters Passed from WASM (Illustrative)                                                                                                                                                              |
| :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `log_event(...)`                   | `host_log_message(level_val: u32, msg_ptr: u32, msg_len: u32, context_json_ptr: u32, context_json_len: u32)`                                                      | `level_val` (e.g., info=2, warn=1), pointers to UTF-8 `msg` string and serialized JSON `context` object.                                                                                                       |
| `if <condition>`                   | `host_evaluate_condition(condition_str_ptr: u32, condition_str_len: u32) -> i32` (returns 0 for false, 1 for true)                                               | Pointer to UTF-8 `condition_str` (e.g., "proposal.valid_amount == true"). Host resolves context variables.                                                                                                  |
| `transition_to "<StageName>"`      | `host_call_process_action(action_name_ptr: u32, action_name_len: u32, args_json_ptr: u32, args_json_len: u32)` (or specific `host_transition_stage` function)        | `"transition_to"`, arguments like stage name (e.g., ""Voting""). Updates internal state of the process instance.                                                                                               |
| `anchor_data {...}`                | 1. (Optional) Resolve `data_ref` if it's not a direct CID: `host_get_context_value(data_ref_ptr, ...)`<br>2. `host_data_write_buffer(...)` if `data_ref` is raw content<br>3. `host_anchor_to_dag(content_cid_ptr, path_ptr, metadata_json_ptr, ...)` | Pointers to resolved content CID, dynamic path string, serialized metadata JSON.                                                                                                                            |
| `perform_metered_action(...)`      | 1. `host_check_resource_authorization(resource_type_val: u32, amount: u64)`<br>2. `host_record_resource_usage(resource_type_val: u32, amount: u64)`                 | `resource_type_val` (e.g., CPU enum value), `amount`.                                                                                                                                                       |
| `mint_token {...}`                 | `host_mint_token(recipient_did_ptr: u32, ..., token_type_ptr: u32, ..., amount: u64, data_json_ptr: u32, ...)`                                                      | Pointers to resolved recipient DID string, token type string, amount, serialized JSON for `data` payload.                                                                                                   |
| `timestamp()` (in `mint_token`)    | `host_get_current_timestamp() -> u64` (or similar)                                                                                                               | Called internally by the host logic for `mint_token` if `timestamp()` is recognized, or `timestamp()` is a CCL stdlib function that calls this.                                                            |
| Accessing context variables (e.g. `proposal.id`, `tally.approved_count`, `self.duration`) | `host_get_context_value(key_path_ptr: u32, key_path_len: u32, buffer_ptr: u32, buffer_len: u32)`                                                | Pointer to UTF-8 `key_path` string (e.g., "proposal.id", "tally.approved_count", "self.duration"). Host returns value.                                                                                           |

### 7.1.7 Contextual Data and Expression Evaluation

*   **Contextual Data**: The CCL execution model assumes the host runtime provides a rich execution context. Variables prefixed with `proposal.`, `tally.`, or `vote.` refer to data within this context. `self.` refers to properties defined in the current CCL block's scope (e.g., a stage's own `duration`). The `host_get_context_value` ABI function is a likely mechanism for WASM to query this data.
*   **Expression Evaluation**:
    *   Simple comparisons (`==`, `>=`) and access to boolean flags (`proposal.valid_amount`) are used in conditions.
    *   String concatenation (`concat(...)`) is used for dynamic path generation.
    *   The `host_evaluate_condition` function would be responsible for parsing and evaluating condition strings against the current context. More complex expressions or functions like `concat()` might be handled by dedicated host calls or by the CCL compiler translating them into a sequence of WASM operations and simpler host calls if the expression language is part of CCL's own capabilities.

### 7.1.8 Error Handling

Host ABI functions return an `i32` status code (0 for success, negative for errors like `HostAbiError::NotPermitted` or `HostAbiError::ResourceLimitExceeded`). The WASM module generated from CCL would need to:
1.  Check the return status of each host call.
2.  Implement appropriate error handling logic. This might involve:
    *   Logging the error via `host_log_message`.
    *   Transitioning the proposal to a "Failed" or "Error" stage.
    *   Trapping the WASM execution (which the `icn-runtime` would then handle).
    The specifics of error handling strategy would be defined by the CCL language design and its standard environment.

---
## 7.2 Role Definitions and Permission Gates: "Treasury Operations"

This example demonstrates how CCL can be used to define distinct roles within a cooperative and enforce permission checks based on the calling agent's assigned role before executing sensitive actions. It also shows how to handle unauthorized attempts gracefully.

### 7.2.1 CCL Source: `treasury_operations.ccl`

```ccl
// treasury_operations.ccl

// --- Role Definitions ---
// Establishes the available roles and their associated permissions.
// This definition would typically be part of a broader governance contract.
roles_def "CooperativeRoles" {
  role "treasurer" {
    description "Manages cooperative funds and financial records."
    permissions [
      "treasury.allocate_budget", 
      "treasury.view_financials",
      "treasury.disburse_funds" 
    ]
  }
  role "member" {
    description "Standard member of the cooperative."
    permissions [
      "proposal.submit", 
      "proposal.vote",
      "general.view_public_records"
    ]
  }
  role "auditor" {
    description "External or internal auditor with read-only access to financial records."
    permissions [
      "treasury.view_financials",
      "governance.view_vote_tallies"
    ]
  }
}

// --- Action Handler for Budget Allocation ---
// This process defines how a specific action, "request_budget_allocation", is handled.
// It uses role-based permission checks.
action_handler "HandleBudgetAllocationRequest" {
  description "Processes requests for allocating funds from a specific budget category."
  
  // Assumed context variables available at runtime for this action:
  // - caller.id: string (DID of the agent invoking the action)
  // - caller.role: string (Role of the agent, resolved by the host based on caller.id and active roles_def)
  // - request.amount: number (Amount requested for allocation)
  // - request.category: string (Budget category, e.g., "operations", "development")
  // - request.justification_cid: string (CID of a document justifying the request)

  triggered_by "budget.allocation.requested" // Event name that triggers this handler

  steps {
    // Step 1: Permission Check
    check_permission {
      required_permission "treasury.allocate_budget" 
      // Implicitly uses caller.role and the active roles_def
      // If fails, the host might halt or the CCL can define fallback behavior.
      // For this example, we assume the host halts or a specific error is raised if check_permission fails.
    }

    // Step 2: Validate Request (simplified)
    // A real scenario would involve more complex validation.
    if request.amount <= 0 {
      log_event(
        name: "budget_allocation.failed",
        level: "error",
        detail: "Requested amount must be positive.",
        context: { request_id: request.id, reason: "InvalidAmount" }
      );
      fail_action("Invalid request amount."); // Explicitly fail the action
    }

    // Step 3: Perform Metered Action (if permission granted and validation passed)
    perform_metered_action("ProcessBudgetAllocation", ResourceType.Transaction, 50);

    // Step 4: Anchor a record of the allocation
    anchor_data {
      path concat("treasury/allocations/", request.category, "/", request.id),
      data {
        allocated_to: caller.id, // Could be a different target if specified
        amount: request.amount,
        category: request.category,
        justification_cid: request.justification_cid,
        timestamp: timestamp()
      },
      metadata { contentType: "application/vnd.icn.treasury.allocation.v1+json" }
    }

    // Step 5: Issue a receipt token
    mint_token {
      token_type "BudgetAllocationReceipt"
      recipient caller.id // Or a designated recipient for the allocation
      amount    1
      data {
        request_id: request.id,
        amount: request.amount,
        category: request.category,
        allocated_at: timestamp()
      }
    }

    // Step 6: Log success
    log_event(
      name: "budget_allocation.succeeded",
      detail: "Budget allocation processed successfully.",
      context: { request_id: request.id, amount: request.amount, category: request.category }
    );
  }

  // --- Fallback for Unauthorized Access ---
  // This block could be invoked by the runtime if the initial `check_permission` fails,
  // OR if the `if caller.has_permission(...)` (alternative style) evaluates to false.
  // The exact mechanism depends on the `check_permission` primitive's behavior.
  // For this example, we'll use an alternative explicit check for illustration if `check_permission` isn't a halting primitive.

  // Alternative/Additional Handling (if check_permission isn't halting or for more nuanced logic):
  /* 
  // This illustrates an alternative way if `check_permission` is not halting.
  // The `steps` block would then be wrapped in an `if caller.has_permission(...)`.
  
  on_fail (type: "PermissionDenied") { // Conceptual: triggered if check_permission fails and sets a specific error type
     log_event(
        name: "budget_allocation.unauthorized",
        level: "warn",
        detail: concat("Caller ", caller.id, " lacks 'treasury.allocate_budget' permission."),
        context: { request_id: request.id, attempted_action: "treasury.allocate_budget" }
     );
     // No further action taken, request is effectively denied.
  }
  */
}
```

### 7.2.2 Purpose & Overview

This CCL contract demonstrates two main concepts:
1.  **Role Definition (`roles_def`)**: How to declare different roles within a system (e.g., "treasurer," "member," "auditor") and associate a list of specific named permissions with each role.
2.  **Permission Gating (`check_permission` or `caller.has_permission`)**: How an `action_handler` can guard critical operations by verifying that the invoking agent (`caller`) possesses the necessary permission as defined in the active `roles_def`. It also shows logging for unauthorized attempts.

The scenario involves a "HandleBudgetAllocationRequest" action that should only be executable by a "treasurer."

### 7.2.3 Key Constructs & Semantics

*   **`roles_def "<Name>" { ... }`**:
    *   Defines a set of roles.
    *   Each `role "<RoleName>" { ... }` block specifies:
        *   `description`: Human-readable description of the role.
        *   `permissions [...]`: An array of strings, where each string is a named permission (e.g., "treasury.allocate_budget").
*   **`action_handler "<Name>" { ... }`**:
    *   Defines a sequence of operations to be performed when a specific event (`triggered_by`) occurs.
    *   `triggered_by`: Specifies the event that invokes this handler.
    *   `steps { ... }`: Contains the primary logic of the action.
*   **`check_permission { required_permission "<PermissionName>" }`**:
    *   This is a dedicated CCL primitive (or a host-provided function that acts like one).
    *   It implicitly checks if the `caller.role` (provided by the host context) has the `required_permission` according to the currently active `roles_def`.
    *   If the permission is not granted, this step would typically cause the action to halt or raise a specific error that could be caught by an `on_fail` block (as conceptualized). The exact behavior (halting vs. error raising) is a design choice for the CCL runtime environment.
*   **`if <condition>` with `caller.has_permission("<PermissionName>")` (Alternative Style)**:
    *   While the example primarily uses `check_permission`, an alternative or complementary approach is a boolean function like `caller.has_permission("permission.name")` that can be used in standard `if` conditions. This allows for more complex logic (e.g., granting access if a user has *any one of* a list of permissions).
*   **Context Variables**:
    *   `caller.id`: The DID of the agent invoking the action.
    *   `caller.role`: The role of the agent, resolved by the host against an active `roles_def`. This is crucial for permission checks.
    *   `request.*`: Data associated with the triggering event/request.
*   **`fail_action("<Reason>")`**: An explicit CCL primitive to stop the current action handler's execution and mark it as failed, potentially with a reason.
*   **`log_event(...)`, `perform_metered_action(...)`, `anchor_data {...}`, `mint_token {...}`**: Standard actions as seen in previous examples.
*   **`on_fail (type: "PermissionDenied") { ... }` (Conceptual)**:
    *   This illustrates a potential CCL construct for declarative error handling or specific failure cases. If `check_permission` (or another step) fails in a way that sets a "PermissionDenied" error type, this block would be executed. This is more advanced and depends on the CCL error handling design.

### 7.2.4 Conceptual DSL AST Mapping (`icn-ccl-dsl`) (Excerpt)

*   **`roles_def "CooperativeRoles" { ... }` block:**
    ```rust
    DslModule::RolesDef {
        name: "CooperativeRoles".to_string(),
        roles: vec![
            RoleDef {
                name: "treasurer".to_string(),
                description: Some("Manages cooperative funds...".to_string()),
                permissions: vec![
                    "treasury.allocate_budget".to_string(), 
                    "treasury.view_financials".to_string(),
                    "treasury.disburse_funds".to_string(),
                ],
            },
            RoleDef {
                name: "member".to_string(),
                description: Some("Standard member of the cooperative.".to_string()),
                permissions: vec![
                    "proposal.submit".to_string(), 
                    "proposal.vote".to_string(),
                    "general.view_public_records".to_string(),
                ],
            },
            // ... other roles ...
        ],
    }
    ```

*   **`action_handler "HandleBudgetAllocationRequest" { ... }` block:**
    This would map to a `DslModule::ActionHandler` or similar structure:
    ```rust
    DslModule::ActionHandler {
        name: "HandleBudgetAllocationRequest".to_string(),
        description: Some("Processes requests for allocating funds...".to_string()),
        triggered_by: "budget.allocation.requested".to_string(),
        steps: vec![
            // Step 1: check_permission
            ActionStep::CheckPermission { // Or a generic FunctionCall
                required_permission: "treasury.allocate_budget".to_string(),
            },
            // Step 2: if request.amount <= 0 { ... fail_action ... }
            ActionStep::If(IfExpr {
                condition_raw: "request.amount <= 0".to_string(), // Or parsed condition
                then_rules: vec![ // Representing the then block
                    RuleValue::Map(vec![ // log_event
                        Rule { key: "log_event".to_string(), value: RuleValue::Map(...) },
                    ]),
                    RuleValue::Map(vec![ // fail_action
                        Rule { key: "fail_action".to_string(), value: RuleValue::String("Invalid request amount.".to_string()) },
                    ]),
                ],
                else_rules: None,
            }),
            // Step 3: perform_metered_action
            ActionStep::PerformMeteredAction {
                action_name: "ProcessBudgetAllocation".to_string(),
                resource_type: "Transaction".to_string(), // Assuming ResourceType enum
                amount: 50,
            },
            // Step 4: anchor_data
            ActionStep::Anchor { path_expr: Some(...), data_ref: None, content_ref: Some(RuleValue::Map(...)) , metadata: Some(...) },
            // Step 5: mint_token
            ActionStep::MintToken { token_type: "BudgetAllocationReceipt".to_string(), recipient_ref: Some("caller.id".to_string()), amount_val: Some(1), data_expr: Some(RuleValue::Map(...)) },
            // Step 6: log_event (success)
            ActionStep::Log(LogParams { name: "budget_allocation.succeeded".to_string(), ... }), // Assuming specific Log ActionStep
        ],
        // Conceptual on_fail block
        // on_fail: Some(vec![ OnFailBlock { error_type: "PermissionDenied", steps: vec![ ...log_event... ] } ]),
    }
    ```

### 7.2.5 Conceptual Opcode Sequence (`icn-ccl-wasm-codegen`)

A simplified conceptual sequence for the `action_handler`:

```rust
// Program.ops (for HandleBudgetAllocationRequest):
[
    // Step 1: Meter initial request
    Opcode::UseResource { resource_type: "CPU", amount: 20 },

    // Step 2: Basic permission/role check
    Opcode::IfConditionExpr { condition_expr_string: "caller.role == "guest"" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "..." },
        Opcode::FailAction { reason_ptr: ..., reason_len: ... },
    Opcode::EndIf,

    // Step 3: Validate Spending Request (single host call)
    Opcode::CallHostFunctionComplex { // Assumes a more complex host call
        function_name: "validate_spending_request_against_budget_def".to_string(),
        args_json: "{\"budget_name\": \"<resolved_request.budget_name>\", ...}", // Host resolves context
        // Host returns 0 on success, error code on failure (e.g., rule violation)
    },
    // Check return status from validate_spending_request; if error, FailAction or Trap.

    // Step 4: Disburse Funds (single host call to economics layer)
    Opcode::CallHostFunctionComplex {
        function_name: "disburse_funds_from_budget".to_string(),
        args_json: "{\"budget_name\": \"<resolved_request.budget_name>\", ...}",
    },
    // Check return status; if error, FailAction or Trap.

    // Step 5: Anchor Data
    Opcode::AnchorData { 
        path_expr: "concat(\"treasury/allocations/\", request.category, \"/\", request.id)",
        data_json_expr: "{...}", // Host resolves context and expressions like timestamp(), generate_uuid()
        metadata_json: "..."
    },

    // Step 6: Log Success
    Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_allocation.succeeded\", ...}" },
]
```
The `roles_def` itself might be compiled into a data structure that the host loads or that `CheckPermission` opcodes refer to by name ("CooperativeRoles").

### 7.2.6 Runtime (Host-ABI) Calls Invoked

| CCL Action / Construct             | Conceptual Host ABI Interaction(s)                                                                                                                               | Key Parameters Passed from WASM (Illustrative)                                                                                                                                                                 |
| :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `roles_def` (loading/activation)   | `host_load_roles_definition(roles_def_json_ptr: u32, roles_def_json_len: u32)` (Called once to establish active roles)                                        | Pointer to serialized JSON or CBOR of the `roles_def` structure.                                                                                                                                             |
| `check_permission { ... }`         | `host_check_permission(caller_did_ptr: u32, ..., permission_name_ptr: u32, ...) -> i32` (0=granted, error code if not)                                          | Pointers to caller's DID (host resolves role) and the required permission string. Host uses active `roles_def`.                                                                                             |
| `caller.has_permission(...)` (alt) | `host_evaluate_condition(condition_str_ptr: u32, ...)` where condition includes `has_permission(...)` which the host parses.                                    | Pointer to condition string.                                                                                                                                                                                 |
| `fail_action("<Reason>")`          | `host_signal_action_failure(reason_ptr: u32, reason_len: u32)`                                                                                                    | Pointer to UTF-8 reason string. Causes the host to mark the current action execution as failed.                                                                                                            |
| `log_event(...)`                   | `host_log_message(...)`                                                                                                                                          | As in previous example.                                                                                                                                                                                      |
| `perform_metered_action(...)`      | `host_check_resource_authorization(...)`, `host_record_resource_usage(...)`                                                                                      | As in previous example. `ResourceType.Transaction` would map to a u32.                                                                                                                                       |
| `anchor_data {...}`                | `host_anchor_to_dag(...)`                                                                                                                                        | As in previous example. Host resolves context vars like `request.id`, `caller.id`, `timestamp()`.                                                                                                              |
| `mint_token {...}`                 | `host_mint_token(...)`                                                                                                                                           | As in previous example. Host resolves `caller.id`, `timestamp()`.                                                                                                                                              |
| Accessing context (e.g. `caller.id`, `request.amount`) | `host_get_context_value(...)`                                                                                                                | As in previous example.                                                                                                                                                                                      |

### 7.2.7 Notes on Role Resolution and Context

*   **Role Context**: A crucial aspect is how `caller.role` is determined by the host. When an agent identified by `caller.id` (a DID) invokes an action, the `icn-runtime` would need to:
    1.  Identify the relevant `roles_def` contract applicable to the current execution scope (e.g., the cooperative or organization instance).
    2.  Look up the `caller.id` within that cooperative's membership records, which should specify the agent's role(s).
    3.  Provide this role string (e.g., "treasurer") as part of the execution context to the WASM module.
*   **Multiple Roles**: If an agent can have multiple roles, the `check_permission` logic (either in the host or via multiple `Opcode::CheckPermissionForRole` calls) would need to iterate through the agent's assigned roles to see if any of them grant the required permission. CCL syntax might need to evolve to handle "any of" or "all of" multiple permissions if this becomes complex.
*   **Dynamic Roles**: The `roles_def` itself could be a CCL contract that is updatable via a governance process, allowing permissions and roles to evolve over time. The `host_load_roles_definition` would then point to the currently active version.

### 7.2.8 Error Handling for Permission Denied

*   If `check_permission` is a halting operation (i.e., it traps WASM execution on failure), the `icn-runtime` would catch this trap and could log the "Permission Denied" event.
*   If `check_permission` returns a status code, the generated WASM would include opcodes to check this status. If access is denied, it could then execute specific CCL logic (like the conceptual `on_fail` block or an `if/else` checking the status) to log the event or take other non-halting actions. The current example uses `check_permission` as potentially halting, with `fail_action` for explicit business logic failures.


---
## 7.3 Budgeting and Resource Metering: "Cooperative Project Spend"

This example illustrates how CCL can define and manage budgets, enforce spending rules based on roles and limits, and integrate with the resource metering system for actions related to budget operations.

### 7.3.1 CCL Source: `project_budget_management.ccl`

```ccl
// project_budget_management.ccl

// --- Budget Definition ---
budget_def "CooperativeProjectsBudgetQ3-2024" {
  description "Operational and grant budget for cooperative projects in Q3 2024."
  total_amount 100000 // Total available in this budget (e.g., in a base currency unit)
  currency_unit "ICN_Credits"

  allocations {
    category "InfrastructureUpgrades" {
      allocated_amount 30000
      description "Funds for upgrading shared compute and storage resources."
    }
    category "CommunityGrants" {
      allocated_amount 50000
      description "Funds for member-initiated project grants."
    }
    category "EducationAndTraining" {
      allocated_amount 20000
      description "Funds for workshops, documentation, and training materials."
    }
  }

  spending_rules {
    // Rule applicable to any spending from this budget
    rule "GeneralSpendingCap" {
      max_spend_per_transaction 5000 // Max amount that can be disbursed in a single tx
      daily_total_spend_limit 15000  // Max total spend from this budget per day
    }

    // Role-specific overrides or additional rules
    rule "TreasurerOverrides" {
      applies_to_role "treasurer" // This rule applies only if caller.role is "treasurer"
      max_spend_per_transaction 10000 // Treasurer can authorize larger individual transactions
      // daily_total_spend_limit still applies from "GeneralSpendingCap" unless also overridden
    }

    rule "GrantCommitteeApproval" {
      applies_to_category "CommunityGrants"
      // Requires a separate approval record (e.g., a CID of an approval vote)
      // This is a conceptual check; actual implementation might involve host calls
      // to verify the existence and validity of such an approval.
      requires_external_approval_ref true 
    }
  }

  // Specifies how actual spending against categories is tracked
  // This implies the host maintains a ledger for this budget_def instance.
  ledger_integration {
    host_managed true 
  }
}

// --- Action Handler for Spending Request ---
action_handler "HandleProjectFundDisbursement" {
  description "Processes requests to disburse funds from a project budget category."
  triggered_by "project.fund.disbursement.requested"

  // Assumed context for this action:
  // - caller.id: string (DID of the agent)
  // - caller.role: string (Role of the agent)
  // - request.budget_name: string (e.g., "CooperativeProjectsBudgetQ3-2024")
  // - request.category_name: string (e.g., "InfrastructureUpgrades")
  // - request.amount: number
  // - request.recipient_did: string (DID of the fund recipient)
  // - request.justification_cid: string
  // - request.approval_ref_cid: string (Optional, for categories like CommunityGrants)

  steps {
    // Step 1: Meter the initial request handling
    perform_metered_action("ProcessDisbursementRequest", ResourceType.CPU, 20);

    // Step 2: Permission Check (e.g., only members or specific roles can request disbursement)
    // For simplicity, we assume a basic role like "member" can request, but treasurer might have higher limits.
    // A more complex check might involve `check_permission` for a specific permission like "budget.request_disbursement"
    if caller.role == "guest" { // Example: guests cannot request funds
        log_event(name: "disbursement.auth.failed", detail: "Guest role cannot request disbursement.");
        fail_action("Unauthorized role for disbursement request.");
    }

    // Step 3: Validate against Budget Spending Rules (Host-assisted)
    // This is a high-level representation. The host would apply the complex rules from budget_def.
    validate_spending_request {
        budget_name request.budget_name
        category    request.category_name
        amount      request.amount
        caller_role caller.role // For role-specific rules
        // Host implicitly checks against total_amount, allocated_amount for category,
        // max_spend_per_transaction, daily_total_spend_limit, and any role/category specific rules.
        // It would also check request.approval_ref_cid if required_external_approval_ref is true for the category.
    }
    // If validate_spending_request fails, it is assumed to be a halting action or sets an error.
    // For this example, assume it halts on failure and the host logs the specific rule violation.

    // Step 4: If validation passes, proceed with disbursement (interaction with economics layer)
    // This implies a host call that would debit the budget ledger and credit the recipient.
    disburse_funds {
        budget_name       request.budget_name
        category_name     request.category_name
        amount            request.amount
        recipient_did     request.recipient_did
        currency_unit     get_budget_property(request.budget_name, "currency_unit") // Get from budget_def
        memo              concat("Disbursement for project: ", request.justification_cid)
    }
    // This primitive is assumed to be metered internally by the host or have its own cost.

    // Step 5: Anchor a record of the disbursement
    anchor_data {
      path concat("budgets/", request.budget_name, "/disbursements/", generate_uuid()), // generate_uuid() is conceptual stdlib
      data {
        requestor_did: caller.id,
        recipient_did: request.recipient_did,
        amount: request.amount,
        category: request.category_name,
        budget: request.budget_name,
        justification_cid: request.justification_cid,
        approval_ref_cid: request.approval_ref_cid, // if provided
        disbursed_at: timestamp()
      },
      metadata { contentType: "application/vnd.icn.budget.disbursement.v1+json" }
    }

    // Step 6: Log success
    log_event(
      name: "project_fund.disbursement.succeeded",
      detail: concat("Successfully disbursed ", request.amount, " from ", request.category_name, " to ", request.recipient_did),
      context: { budget: request.budget_name, category: request.category_name, amount: request.amount }
    );
  }
}
```

### 7.3.2 Purpose & Overview

This CCL example focuses on:
1.  **Budget Definition (`budget_def`)**: Defining a named budget with a total amount, currency, specific allocations to categories, and enforceable spending rules (general caps, role-specific limits, external approval requirements).
2.  **Action Handling for Spending (`action_handler`)**: Processing a fund disbursement request against a defined budget. This involves initial metering, basic permission checks, complex validation against the budget's spending rules (assumed to be largely host-assisted), the disbursement action itself (interacting with an underlying ledger), and finally, anchoring and logging the transaction.

It showcases how CCL can model financial controls and integrate them with the ICN's economic and data-anchoring primitives.

### 7.3.3 Key Constructs & Semantics

*   **`budget_def "<Name>" { ... }`**: Defines a budget.
    *   `total_amount`: The overall budget pool.
    *   `currency_unit`: The currency in which amounts are denominated.
    *   `allocations { category "<CatName>" { ... } }`: Defines sub-pools within the budget for specific purposes, each with its `allocated_amount`.
    *   `spending_rules { rule "<RuleName>" { ... } }`: Defines constraints on spending.
        *   `max_spend_per_transaction`, `daily_total_spend_limit`: General caps.
        *   `applies_to_role`: Makes a rule conditional on the caller's role.
        *   `applies_to_category`: Makes a rule conditional on the target budget category.
        *   `requires_external_approval_ref`: Indicates a need for an external proof of approval.
    *   `ledger_integration { host_managed true }`: Declares that the host system is responsible for tracking balances against this budget definition.
*   **`action_handler "HandleProjectFundDisbursement"`**: Manages the disbursement workflow.
    *   `perform_metered_action`: As seen before, for initial request processing cost.
    *   **`validate_spending_request { ... }` (Conceptual Primitive/Host Call)**:
        *   This is a key conceptual step representing a complex host-side validation.
        *   The host would take the request parameters (`budget_name`, `category`, `amount`, `caller_role`) and check them against the rules defined in the specified `budget_def` instance.
        *   This includes checking category allocations, overall budget limits, transaction size limits (considering role-based overrides), daily limits, and external approval requirements.
        *   A failure here would typically be a halting error, with the host logging the specific rule violation.
    *   **`disburse_funds { ... }` (Conceptual Primitive/Host Call)**:
        *   Represents the actual economic transaction.
        *   The host would interact with the ICN's economic layer/ledger system to debit the specified budget category and credit the recipient's account.
        *   This operation itself would have resource implications and safety checks within the economic system.
    *   `get_budget_property(request.budget_name, "currency_unit")` (Conceptual Stdlib): Accesses properties of the named `budget_def`.
    *   `generate_uuid()` (Conceptual Stdlib): Generates a unique ID, useful for record-keeping.

### 7.3.4 Conceptual DSL AST Mapping (`icn-ccl-dsl`) (Excerpt)

*   **`budget_def "CooperativeProjectsBudgetQ3-2024" { ... }`:**
    ```rust
    DslModule::BudgetDef {
        name: "CooperativeProjectsBudgetQ3-2024".to_string(),
        description: Some("Operational and grant budget...".to_string()),
        total_amount: RuleValue::Number(100000.0.into()),
        currency_unit: Some("ICN_Credits".to_string()),
        allocations: vec![
            BudgetAllocation {
                category_name: "InfrastructureUpgrades".to_string(),
                allocated_amount: RuleValue::Number(30000.0.into()),
                description: Some("Funds for upgrading...".to_string()),
            },
            // ... other allocations ...
        ],
        spending_rules: vec![
            SpendingRule {
                name: "GeneralSpendingCap".to_string(),
                applies_to_role: None,
                applies_to_category: None,
                properties: vec![
                    Rule { key: "max_spend_per_transaction".to_string(), value: RuleValue::Number(5000.0.into()) },
                    Rule { key: "daily_total_spend_limit".to_string(), value: RuleValue::Number(15000.0.into()) },
                ],
            },
            SpendingRule {
                name: "TreasurerOverrides".to_string(),
                applies_to_role: Some("treasurer".to_string()),
                applies_to_category: None,
                properties: vec![
                     Rule { key: "max_spend_per_transaction".to_string(), value: RuleValue::Number(10000.0.into()) },
                ],
            },
            // ... other rules ...
        ],
        ledger_integration: Some(LedgerIntegrationParams { host_managed: true }),
    }
    ```

*   **`action_handler "HandleProjectFundDisbursement"` steps:**
    ```rust
    // Within DslModule::ActionHandler steps vec!:
    ActionStep::PerformMeteredAction { action_name: "ProcessDisbursementRequest", resource_type: "CPU", amount: 20 },
    ActionStep::If(IfExpr { // Basic role check example
        condition_raw: "caller.role == "guest""",
        then_rules: vec![ /* log_event, fail_action */ ],
        else_rules: None,
    }),
    ActionStep::FunctionCall { // Conceptual for validate_spending_request
        name: "validate_spending_request".to_string(),
        args: vec![
            Rule { key: "budget_name".to_string(), value: RuleValue::Expression("request.budget_name".to_string()) },
            // ... other args ...
        ],
    },
    ActionStep::FunctionCall { // Conceptual for disburse_funds
        name: "disburse_funds".to_string(),
        args: vec![ /* ... */ ],
    },
    ActionStep::Anchor { ... },
    ActionStep::Log(LogParams { ... }),
    ```

### 7.3.5 Conceptual Opcode Sequence (`icn-ccl-wasm-codegen`)

For the `action_handler`:
```rust
// Program.ops (for HandleProjectFundDisbursement):
[
    // Step 1: Meter initial request
    Opcode::UseResource { resource_type: "CPU", amount: 20 },

    // Step 2: Basic permission/role check
    Opcode::IfConditionExpr { condition_expr_string: "caller.role == "guest"" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "..." },
        Opcode::FailAction { reason_ptr: ..., reason_len: ... },
    Opcode::EndIf,

    // Step 3: Validate Spending Request (single host call)
    Opcode::CallHostFunctionComplex { // Assumes a more complex host call
        function_name: "validate_spending_request_against_budget_def".to_string(),
        args_json: "{\"budget_name\": \"<resolved_request.budget_name>\", ...}", // Host resolves context
        // Host returns 0 on success, error code on failure (e.g., rule violation)
    },
    // Check return status from validate_spending_request; if error, FailAction or Trap.

    // Step 4: Disburse Funds (single host call to economics layer)
    Opcode::CallHostFunctionComplex {
        function_name: "disburse_funds_from_budget".to_string(),
        args_json: "{\"budget_name\": \"<resolved_request.budget_name>\", ...}",
    },
    // Check return status; if error, FailAction or Trap.

    // Step 5: Anchor Data
    Opcode::AnchorData { 
        path_expr: "concat(\"budgets/\", request.budget_name, \"/disbursements/\", generate_uuid())",
        data_json_expr: "{...}", // Host resolves context and expressions like timestamp(), generate_uuid()
        metadata_json: "..."
    },

    // Step 6: Log Success
    Opcode::CallHostFunction { function_name: "log_event", args_json: "{\"name\":\"budget_allocation.succeeded\", ...}" },
]
```
The `budget_def` itself is primarily a data structure loaded and interpreted by the host, especially by the `validate_spending_request_against_budget_def` and `disburse_funds_from_budget` host functions.

### 7.3.6 Runtime (Host-ABI) Calls Invoked

| CCL Action / Construct             | Conceptual Host ABI Interaction(s)                                                                                                                               | Key Parameters Passed (Illustrative)                                                                                                                                                            |
| :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `budget_def` (loading)             | `host_load_budget_definition(budget_def_json_ptr: u32, ...)` (Called once to establish the budget rules)                                                          | Pointer to serialized `budget_def`.                                                                                                                                                             |
| `perform_metered_action`           | `host_check_resource_authorization(...)`, `host_record_resource_usage(...)`                                                                                      | As before.                                                                                                                                                                                      |
| `validate_spending_request { ... }`| `host_validate_spending_request(request_details_json_ptr: u32, ...) -> i32`                                                                                      | Pointer to serialized JSON of request details (budget name, category, amount, caller role, approval_ref_cid). Host uses loaded `budget_def`. Returns 0 or error code.                               |
| `disburse_funds { ... }`           | `host_disburse_budgeted_funds(disbursement_details_json_ptr: u32, ...) -> i32`                                                                                    | Pointer to serialized JSON of disbursement details (budget, category, amount, recipient, currency). Interacts with ledger. Returns 0 or error code.                                              |
| `get_budget_property(...)`         | `host_get_budget_property(budget_name_ptr: u32, ..., property_path_ptr: u32, ...) -> buffer`                                                                   | Pointers to budget name and property path (e.g. "currency_unit").                                                                                                                                  |
| `generate_uuid()`                  | `host_generate_uuid(buffer_ptr: u32, buffer_len: u32)`                                                                                                           | Host writes a new UUID string into the provided buffer.                                                                                                                                                     |
| `log_event(...)`, `anchor_data {...}` | As in previous examples.                                                                                                                                         | As before.                                                                                                                                                                                      |

### 7.3.7 Notes on Budget State and Host Interaction

*   **Host-Managed State**: The actual balances for the `total_amount` and `category.allocated_amount` within a `budget_def` instance are managed by the host (as per `ledger_integration { host_managed true }`). The CCL defines the rules, but the host maintains the stateful ledger.
*   **Complex Validation**: `validate_spending_request` is a significant host function. It encapsulates the logic of checking against all applicable rules in the `budget_def` (caps, role-based rules, daily limits, external approvals). This keeps the WASM module relatively simple, offloading complex stateful checks to the trusted host environment.
*   **Atomicity**: The `disburse_funds` host call would ideally be atomic with respect to the budget ledger update. If the disbursement fails for reasons internal to the economic system (e.g., insufficient funds in the cooperative's main account, invalid recipient), the host function should return an error, and no change to the budget ledger (for this specific disbursement) should occur.
*   **Concurrency**: The host needs to handle potential concurrent requests against the same budget, especially for checks like `daily_total_spend_limit` and when updating ledger balances.

This completes the draft for Section 7.3. I will now append this to the `docs/ccl_spec_chapter_7_examples.md` file. 