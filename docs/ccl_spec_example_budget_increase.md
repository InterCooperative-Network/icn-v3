# CCL Specification (Draft) - Chapter 7: Examples and Walkthroughs

This chapter provides practical examples of CCL code, demonstrating how various constructs are used to define cooperative logic. Each example will be accompanied by:

*   A conceptual mapping to the `icn-ccl-dsl` Abstract Syntax Tree (AST), highlighting how CCL structures are represented internally.
*   An expected sequence of custom `Opcode`s generated by `icn-ccl-wasm-codegen`, illustrating the transformation into a lower-level instruction set.
*   A list of key `host-abi` functions that the resulting WASM module would interact with during runtime execution.

## 7.1 Multi-Stage Proposal Lifecycle: "Budget Increase"

This example implements a three-stage workflow for budget proposals: Draft, Voting, and Approved/Rejected. It demonstrates metadata definition, state transitions based on events and conditions, and interaction with core ICN primitives like data anchoring, resource metering, and token minting.

### 7.1.1 CCL Source: `budget_increase_proposal.ccl`

```ccl
// budget_increase_proposal.ccl

proposal_def "Budget Increase" {
  description "Request to raise the operational budget for the next fiscal period."
  duration    "14d" // Default voting duration if not specified by the voting stage
  min_votes   5     // Minimum number of votes required for the proposal to be considered (not necessarily quorum for approval)
  // Assumed context variables available at runtime for an instance of this proposal:
  // - proposal.id: string (unique ID of this proposal instance)
  // - proposal.submitter_id: string (DID of the submitter)
  // - proposal.content: any (the full content/details of the budget request)
  // - proposal.valid_amount: boolean (pre-validated flag indicating if requested amount is sensible)
}

process_def "BudgetIncreaseProcess" {
  // Defines the state machine for this proposal type
  stages {
    stage "Draft" {
      enter_action { // Action taken immediately upon entering the "Draft" stage
        log_event(
            name: "budget_proposal.draft_started", 
            detail: "New budget proposal instance created and entered Draft stage.",
            context: { proposal_id: proposal.id }
        );
      }
      on "submit" { // Event triggering a state evaluation
        if proposal.valid_amount == true { // Condition using a context variable
          transition_to "Voting"
        } else {
          log_event(
            name: "budget_proposal.invalid_submission",
            level: "warn", // Example of specifying log level
            detail: "Submission rejected due to invalid amount.",
            context: { proposal_id: proposal.id, reason: "InvalidAmount" }
          );
          // Implicitly stays in "Draft" or could transition to a "FailedValidation" stage
          // For this example, we assume it remains in Draft for correction.
        }
      }
    } // End of "Draft" stage

    stage "Voting" {
      enter_action {
        anchor_data { 
            path concat("proposals/", proposal.id, "/budget_request_v1.ccl_content"), // Dynamic path
            data proposal.content, // Anchors the proposal content itself
            metadata { contentType: "application/vnd.icn.ccl.proposal.v1+json" } // Example metadata
        }
        log_event(
            name: "budget_proposal.voting_started",
            detail: "Proposal content anchored. Voting period now open.",
            context: { proposal_id: proposal.id, voting_duration: self.duration } // self refers to current block's properties
        );
      }
      duration "10d" // Specific duration for this stage, overrides proposal_def default for voting
      
      on "vote_cast" { // Event for each vote
        perform_metered_action("ProcessIncomingVote", ResourceType.CPU, 10); 
        // Actual vote tallying logic might be complex, handled by host or specific opcodes
      }

      on "voting_closed" { // Event when voting period ends
        // Assumed context variables available from voting system:
        // - tally.approved_count: number
        // - tally.rejected_count: number
        // - tally.total_votes_cast: number
        if tally.approved_count >= proposal.min_votes { // Using min_votes from proposal_def
          transition_to "Approved"
        } else {
          transition_to "Rejected"
        }
      }
    } // End of "Voting" stage

    stage "Approved" {
      enter_action {
        log_event(
            name: "budget_proposal.approved",
            detail: "Budget proposal approved.",
            context: { proposal_id: proposal.id }
        );
        mint_token {
          token_type      "BudgetApprovalReceipt"
          recipient proposal.submitter_id
          amount    1 // A single non-fungible receipt token
          data      { 
            proposal_id: proposal.id, 
            approved_on: timestamp(), // timestamp() is a stdlib function
            document_cid: self.previous_stage_anchor_cid // Conceptual: access to output of previous action
          } 
        }
      }
    } // End of "Approved" stage

    stage "Rejected" {
        enter_action {
            log_event(
                name: "budget_proposal.rejected",
                level: "info",
                detail: "Budget proposal rejected.",
                context: { proposal_id: proposal.id }
            );
        }
    } // End of "Rejected" stage

  } // End of stages
} // End of process_def
```

### 7.1.2 Purpose & Overview

This CCL contract defines a structured, multi-stage process for handling "Budget Increase" proposals. It ensures that proposals are logged, their content is verifiably anchored, voting is metered, and a non-fungible token receipt is issued upon successful approval. The process transitions through "Draft," "Voting," and "Approved" (or "Rejected") stages based on defined events and conditions.

### 7.1.3 Key Constructs & Semantics

*   **`proposal_def`**: Declares metadata and default parameters for the "Budget Increase" proposal type, such as its `description`, default `duration` for actions/stages, and `min_votes` required for approval.
*   **`process_def`**: Defines the state machine (`stages`) for the proposal lifecycle.
*   **`stage "<Name>"`**: Represents a distinct state in the process. Each stage can have:
    *   `enter_action {}`: A block of actions executed immediately upon transitioning into that stage.
    *   `on "<event_name>" {}`: Defines event handlers that are evaluated when the specified event occurs while the process is in this stage.
    *   Properties like `duration` specific to that stage.
*   **`if <condition> { ... } else { ... }`**: Standard conditional logic. Conditions can reference proposal properties (e.g., `proposal.valid_amount`) or tallies from other processes (e.g., `tally.approved_count`).
*   **`transition_to "<StageName>"`**: An action (likely a host call) that moves the process instance to a different stage.
*   **`log_event(...)`**: A function call to log structured events, mapping to `host_log_message`.
*   **`anchor_data {}`**: An action to store data verifiably on the ICN DAG, mapping to relevant host ABI calls for data writing and anchoring.
*   **`perform_metered_action(...)`**: Explicitly declares that an action consumes resources, interfacing with the ICN economics system via `host_check_resource_authorization` and `host_record_resource_usage`.
*   **`mint_token {}`**: An action to create new tokens, mapping to `host_mint_token`.
*   **Contextual Variables**: The CCL code relies on runtime-provided context (e.g., `proposal.id`, `proposal.submitter_id`, `tally.approved_count`). `self.` refers to properties defined in the current CCL block's scope (e.g., `self.duration` within the "Voting" stage refers to its "10d" duration). `timestamp()` is an example of a CCL standard library function.

### 7.1.4 Conceptual DSL AST Mapping (`icn-ccl-dsl`) (Excerpt)

The `icn-ccl-compiler` would lower the CCL source into `Vec<DslModule>` instances.

*   **`proposal_def "Budget Increase" { ... }` block:**
    ```rust
    DslModule::Proposal {
        name: "Budget Increase".to_string(),
        version: None, // No version specified in this example's proposal_def
        rules: vec![
            Rule { key: "description".to_string(), value: RuleValue::String("Request to raise...".to_string()) },
            Rule { key: "duration".to_string(), value: RuleValue::String("14d".to_string()) }, // Or a Duration type
            Rule { key: "min_votes".to_string(), value: RuleValue::Number(5.0.into()) },
        ],
    }
    ```

*   **`process_def "BudgetIncreaseProcess" { ... }` block:**
    ```rust
    DslModule::Section { // process_def often maps to a generic Section or a specific Process DslModule
        kind: "process_def".to_string(),
        title: Some("BudgetIncreaseProcess".to_string()),
        rules: vec![ /* rules representing stages */ ],
    }
    ```
    Each `stage` within `stages { ... }` would become a nested `DslModule::Section` with `kind: "stage"`.

*   **`stage "Draft" { enter_action { log_event(...) } ... }`:**
    A `DslModule::Section` for the stage:
    ```rust
    DslModule::Section {
        kind: "stage".to_string(),
        title: Some("Draft".to_string()),
        rules: vec![
            Rule { // Representing enter_action
                key: "enter_action".to_string(),
                value: RuleValue::Map(vec![ // Map of actions
                    Rule { 
                        key: "log_event".to_string(), // Function call representation
                        value: RuleValue::Map(vec![
                            Rule { key: "name".to_string(), value: RuleValue::String("budget_proposal.draft_started".to_string()) },
                            Rule { key: "detail".to_string(), value: RuleValue::String("New budget proposal...".to_string()) },
                            Rule { key: "context".to_string(), value: RuleValue::Map(vec![
                                Rule { key: "proposal_id".to_string(), value: RuleValue::Expression("proposal.id".to_string()) }
                            ])},
                        ]),
                    },
                ]),
            },
            Rule { // Representing on "submit" handler
                key: "on".to_string(),
                value: RuleValue::Map(vec![
                    Rule { key: "event_name".to_string(), value: RuleValue::String("submit".to_string()) },
                    Rule { key: "handler_logic".to_string(), value: RuleValue::If(
                        IfExpr {
                            condition_raw: "proposal.valid_amount == true".to_string(),
                            then_rules: vec![ /* Rule for transition_to "Voting" */ ],
                            else_rules: Some(vec![ /* Rule for log_event and implicit stay */ ]),
                        }
                    )},
                ]),
            },
            // ... other rules or properties of the stage ...
        ],
    }
    ```

*   **`anchor_data { path ..., data ..., metadata ... }` within an `enter_action`:**
    This would be an `ActionStep` variant within the DSL, perhaps:
    ```rust
    // Conceptual ActionStep variant within a DslModule::ActionHandler or similar structure
    ActionStep::Anchor {
        path_expr: Some("concat("proposals/", proposal.id, "/budget_request_v1.ccl_content")".to_string()),
        data_ref: Some("proposal.content".to_string()), // Reference to context data
        metadata: Some(vec![
            Rule { key: "contentType".to_string(), value: RuleValue::String("application/vnd.icn.ccl.proposal.v1+json".to_string()) }
        ]),
        content_ref: None, // as data_ref is used
    }
    ```

*   **`perform_metered_action("ProcessIncomingVote", ResourceType.CPU, 10);`**
    ```rust
    ActionStep::PerformMeteredAction {
        action_name: "ProcessIncomingVote".to_string(),
        resource_type: "CPU".to_string(), // Assuming ResourceType enum variant mapped to string
        amount: 10,
    }
    ```

### 7.1.5 Conceptual Opcode Sequence (`icn-ccl-wasm-codegen`)

The `WasmGenerator` would convert the DSL AST into a linear sequence of custom `Opcode`s. This is a simplified conceptual flow:

```rust
// Program.ops:
[
    // Proposal Definition part
    Opcode::DefineContextSchema { schema_name: "Budget Increase" }, // Or similar to set up expected context
    Opcode::SetProperty { key: "proposal_def.description", value_json: ""Request to raise..."" },
    Opcode::SetProperty { key: "proposal_def.duration", value_json: ""14d"" },
    Opcode::SetProperty { key: "proposal_def.min_votes", value_json: "5" },

    // Process Definition: BudgetIncreaseProcess
    Opcode::BeginProcessDef { name: "BudgetIncreaseProcess" },

    // Stage: Draft
    Opcode::DefineStage { name: "Draft" },
    Opcode::OnStageEnter { stage_name: "Draft" }, // Marks block for stage entry actions
        Opcode::CallHostFunction { // For log_event
            function_name: "log_event".to_string(),
            // Arguments serialized, e.g., as JSON array of objects or a single JSON object
            args_json: "{"name":"budget_proposal.draft_started", "detail":"...", "context":{"proposal_id":"<resolved_proposal.id>"}}"
        },
    Opcode::EndStageActions, // End of enter_action
    
    Opcode::OnEvent { event_name: "submit", stage_context: "Draft" }, // Handler for "submit" in "Draft"
        Opcode::IfConditionExpr { condition_expr_string: "proposal.valid_amount == true" }, // Host evaluates this
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Voting"" },
        Opcode::Else,
            Opcode::CallHostFunction { function_name: "log_event", args_json: "{"name":"budget_proposal.invalid_submission", ...}" },
        Opcode::EndIf,
    Opcode::EndOnEvent, // End of "submit" handler

    // Stage: Voting
    Opcode::DefineStage { name: "Voting" },
    Opcode::SetStageProperty { stage_name: "Voting", key: "duration", value_json: ""10d"" },
    Opcode::OnStageEnter { stage_name: "Voting" },
        Opcode::AnchorData { // Resolves expressions and context data before calling host_anchor
            path_expr: "concat("proposals/", proposal.id, "/budget_request_v1.ccl_content")",
            data_ref: "proposal.content",
            metadata_json: "{"contentType":"application/vnd.icn.ccl.proposal.v1+json"}"
        },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{"name":"budget_proposal.voting_started", ...}" },
    Opcode::EndStageActions,

    Opcode::OnEvent { event_name: "vote_cast", stage_context: "Voting" },
        Opcode::UseResource { resource_type: "CPU", amount: 10 }, // "ProcessIncomingVote" is descriptive label
        // Potentially other opcodes for vote processing if not fully on host
    Opcode::EndOnEvent,

    Opcode::OnEvent { event_name: "voting_closed", stage_context: "Voting" },
        Opcode::IfConditionExpr { condition_expr_string: "tally.approved_count >= proposal.min_votes" },
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Approved"" },
        Opcode::Else,
            Opcode::CallHostFunction { function_name: "transition_to", args_json: ""Rejected"" },
        Opcode::EndIf,
    Opcode::EndOnEvent,

    // Stage: Approved
    Opcode::DefineStage { name: "Approved" },
    Opcode::OnStageEnter { stage_name: "Approved" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{"name":"budget_proposal.approved", ...}" },
        Opcode::MintToken {
            token_type: "BudgetApprovalReceipt",
            recipient_ref: "proposal.submitter_id",
            amount: 1,
            data_json_expr: "{"proposal_id": proposal.id, "approved_on": timestamp(), "document_cid": self.previous_stage_anchor_cid }"
        },
    Opcode::EndStageActions,
    
    // Stage: Rejected
    Opcode::DefineStage { name: "Rejected" },
    Opcode::OnStageEnter { stage_name: "Rejected" },
        Opcode::CallHostFunction { function_name: "log_event", args_json: "{"name":"budget_proposal.rejected", ...}" },
    Opcode::EndStageActions,

    Opcode::EndProcessDef,
]
```

### 7.1.6 Runtime (Host-ABI) Calls Invoked

The generated WASM, when executed by `icn-runtime`, would interact with `icn_host` functions:

| CCL Action / Construct             | Conceptual Host ABI Interaction(s)                                                                                                                               | Key Parameters Passed from WASM (Illustrative)                                                                                                                                                              |
| :--------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `log_event(...)`                   | `host_log_message(level_val: u32, msg_ptr: u32, msg_len: u32, context_json_ptr: u32, context_json_len: u32)`                                                      | `level_val` (e.g., info=2, warn=1), pointers to UTF-8 `msg` string and serialized JSON `context` object.                                                                                                       |
| `if <condition>`                   | `host_evaluate_condition(condition_str_ptr: u32, condition_str_len: u32) -> i32` (returns 0 for false, 1 for true)                                               | Pointer to UTF-8 `condition_str` (e.g., "proposal.valid_amount == true"). Host resolves context variables.                                                                                                  |
| `transition_to "<StageName>"`      | `host_call_process_action(action_name_ptr: u32, action_name_len: u32, args_json_ptr: u32, args_json_len: u32)` (or specific `host_transition_stage` function)        | `"transition_to"`, arguments like stage name (e.g., ""Voting""). Updates internal state of the process instance.                                                                                               |
| `anchor_data {...}`                | 1. (Optional) Resolve `data_ref` if it's not a direct CID: `host_get_context_value(data_ref_ptr, ...)`<br>2. `host_data_write_buffer(...)` if `data_ref` is raw content<br>3. `host_anchor_to_dag(content_cid_ptr, path_ptr, metadata_json_ptr, ...)` | Pointers to resolved content CID, dynamic path string, serialized metadata JSON.                                                                                                                            |
| `perform_metered_action(...)`      | 1. `host_check_resource_authorization(resource_type_val: u32, amount: u64)`<br>2. `host_record_resource_usage(resource_type_val: u32, amount: u64)`                 | `resource_type_val` (e.g., CPU enum value), `amount`.                                                                                                                                                       |
| `mint_token {...}`                 | `host_mint_token(recipient_did_ptr: u32, ..., token_type_ptr: u32, ..., amount: u64, data_json_ptr: u32, ...)`                                                      | Pointers to resolved recipient DID string, token type string, amount, serialized JSON for `data` payload.                                                                                                   |
| `timestamp()` (in `mint_token`)    | `host_get_current_timestamp() -> u64` (or similar)                                                                                                               | Called internally by the host logic for `mint_token` if `timestamp()` is recognized, or `timestamp()` is a CCL stdlib function that calls this.                                                            |
| Accessing context variables (e.g. `proposal.id`, `tally.approved_count`, `self.duration`) | `host_get_context_value(key_path_ptr: u32, key_path_len: u32, buffer_ptr: u32, buffer_len: u32)`                                                | Pointer to UTF-8 `key_path` string (e.g., "proposal.id", "tally.approved_count", "self.duration"). Host returns value.                                                                                           |

### 7.1.7 Contextual Data and Expression Evaluation

*   **Contextual Data**: The CCL execution model assumes the host runtime provides a rich execution context. Variables prefixed with `proposal.`, `tally.`, or `vote.` refer to data within this context. `self.` refers to properties defined in the current CCL block's scope (e.g., a stage's own `duration`). The `host_get_context_value` ABI function is a likely mechanism for WASM to query this data.
*   **Expression Evaluation**:
    *   Simple comparisons (`==`, `>=`) and access to boolean flags (`proposal.valid_amount`) are used in conditions.
    *   String concatenation (`concat(...)`) is used for dynamic path generation.
    *   The `host_evaluate_condition` function would be responsible for parsing and evaluating condition strings against the current context. More complex expressions or functions like `concat()` might be handled by dedicated host calls or by the CCL compiler translating them into a sequence of WASM operations and simpler host calls if the expression language is part of CCL's own capabilities.

### 7.1.8 Error Handling

Host ABI functions return an `i32` status code (0 for success, negative for errors like `HostAbiError::NotPermitted` or `HostAbiError::ResourceLimitExceeded`). The WASM module generated from CCL would need to:
1.  Check the return status of each host call.
2.  Implement appropriate error handling logic. This might involve:
    *   Logging the error via `host_log_message`.
    *   Transitioning the proposal to a "Failed" or "Error" stage.
    *   Trapping the WASM execution (which the `icn-runtime` would then handle).
    The specifics of error handling strategy would be defined by the CCL language design and its standard environment. 